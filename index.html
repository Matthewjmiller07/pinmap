<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PinMap App</title>
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <!-- Custom CSS -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">

     <style>
       /* Custom Styles */

       body {
    font-family: 'Inter', sans-serif;
    background-color: #f8f9fa; /* Light grey background for contrast */
    background: linear-gradient(to right, #f8f9fa, #ffffff); /* Subtle gradient */
    color: #212529;
    margin: 0;
    padding: 0;
}

/* Container Styles */
.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 15px;
}

/* Button Styles */
.btn {
    border-radius: 0.375rem;
    padding: 0.5rem 1rem;
    font-size: 1rem;
    font-weight: 500;
    text-transform: capitalize;
    transition: background-color 0.3s ease, transform 0.2s ease;
}

.btn:hover {
    opacity: 0.9;
    transform: scale(1.02);
}

/* Headings */
h1 {
    font-weight: 600;
    color: #495057; /* Neutral dark grey for headings */
}

/* Map and Chart Styles */
#map {
    width: 100%; /* Use the full width of the container */
    height: 400px; /* Set a fixed height for the map */
    margin: 40px 0; /* Add vertical spacing */
    border-radius: 8px; /* Rounded corners */
    background: #ffffff; /* Background color for container */
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Subtle shadow */
    position: relative; /* Ensure internal positioning works correctly */
    overflow: hidden; /* Clip any overflowing content */
}

#chart {
    width: 100%; /* Use the full width of the container */
    max-width: 100%; /* Prevent it from exceeding its container */
    height: auto; /* Ensure the height scales dynamically */
    margin: 40px 0; /* Vertical spacing */
    padding: 10px; /* Add internal spacing to prevent overlap with rounded edges */
    border-radius: 8px; /* Rounded corners */
    background: #ffffff; /* Background color for container */
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Subtle shadow */
    overflow: hidden; /* Clip any overflowing content */
    position: relative; /* Ensure internal positioning works correctly */
}


/* Ensure the chart spans the full width */
#chart svg {
    display: block; /* Prevent inline SVG issues */
    width: calc(100% - 20px); /* Ensure it stays within the container padding */
    height: auto; /* Maintain aspect ratio */
    border-radius: inherit; /* Match parent container's rounded corners */
    overflow: hidden; /* Clip content inside the SVG */
}

/* Section Spacing */
.section {
    margin-top: 40px;
    margin-bottom: 40px; /* Add bottom spacing to prevent overlaps */
    padding: 20px;
    border-radius: 8px;
    background-color: #ffffff;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* Table Styles */
.table-responsive {
    width: 100%;
    max-height: 400px; /* Set a max height for better UX */
    overflow-y: auto; /* Add scrolling if content exceeds max height */
    overflow-x: auto; /* Enable horizontal scrolling for wide tables */
    border: 1px solid #dee2e6; /* Subtle border for tables */
    border-radius: 8px;
    margin-bottom: 40px; /* Ensure spacing between tables */
    background: #ffffff;
}

/* Ensure Tables Are Neatly Styled */
table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 0;
    table-layout: auto; /* Adjust for dynamic content */
}

thead th {
    position: sticky;
    top: 0;
    background: #f8f9fa; /* Sticky header background */
    z-index: 1;
}

th, td {
    padding: 0.75rem;
    text-align: left;
    border-bottom: 1px solid #dee2e6;
}

tfoot td {
    font-weight: bold;
    text-align: right;
    background-color: #f2f2f2;
}

/* Form Styles */
.form-control {
    font-size: 1rem;
    padding: 0.75rem;
}

/* Modal Styles */
.modal-body {
    max-height: 80vh; /* Prevent overflow */
    overflow-y: auto; /* Add scrolling for content */
}

.modal-dialog {
    max-width: 500px; /* Constrain modal width */
    margin: 20px auto;
}

/* Navbar Adjustments */
.navbar {
    background-color: #ffffff;
    box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
    margin-bottom: 20px; /* Add spacing below navbar */
}

.navbar-brand {
    font-size: 1.5rem;
    font-weight: 600;
    color: #495057;
}

.navbar-toggler-icon {
    filter: brightness(0.5); /* Adjust icon brightness */
}

/* Centering Content */
.text-center {
    text-align: center;
}

.auth-buttons, .reset-button, .share-button {
    margin: 20px auto;
}

/* Hide Elements by Default */
.hidden {
    display: none;
}

/* Responsive Adjustments for Tables */
@media (max-width: 768px) {
    .table-responsive {
        max-height: 300px; /* Adjust for smaller screens */
    }

    .modal-dialog {
        max-width: 100%; /* Allow full width for smaller screens */
    }
}

@media (max-width: 576px) {
    .table-responsive {
        max-height: 250px;
    }
}

#chart-wrapper {
    width: 100%; /* Ensure it spans the full width of its container */
    max-width: 1200px; /* Optional: Limit the width */
    margin: 0 auto; /* Center it horizontally */
    padding: 20px; /* Add some padding inside the wrapper */
    border-radius: 8px; /* Match the rounded edges */
    background: #ffffff; /* Same background as the chart container */
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Subtle shadow for distinction */
    overflow: hidden; /* Prevent content from spilling out */
    display: flex; /* Align child (#chart) properly */
    justify-content: center;
    align-items: center;
}
    </style>
    <!-- Favicon to prevent 404 error -->
    <link rel="icon" href="data:," />
</head>
<body>

    <nav class="navbar navbar-expand-lg navbar-light bg-light shadow-sm">
        <div class="container">
            <a class="navbar-brand" href="#">PinMap App</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <button id="login-button" class="btn btn-primary me-2">Login</button>
                        <button id="logout-button" class="btn btn-danger hidden">Logout</button>
                    </li>
                </ul>
            </div>
        </div>
    </nav>
    
    <div class="container mt-4">
        <h1 class="text-center">PinMap App</h1>
    
        <!-- User Info -->
        <div id="user-info" class="text-center hidden">
            <p>Welcome, <span id="user-name"></span>!</p>
        </div>
    </div>

        <!-- Add Location Form -->
        <div id="add-location-form" class="section hidden">
            <form id="location-form">
                <div class="form-group">
                    <label for="city">Enter City:</label>
                    <input type="text" id="city" class="form-control" placeholder="City" required>
                </div>
                <div class="form-group">
                    <label for="state">Enter State (optional):</label>
                    <input type="text" id="state" class="form-control" placeholder="State">
                </div>
                <div class="form-group">
                    <label for="zip">Enter ZIP Code:</label>
                    <input type="text" id="zip" class="form-control" placeholder="ZIP Code">
                </div>
                <button type="submit" class="btn btn-success">Add Location</button>
            </form>
        </div>

        <!-- Reset Button -->
        <div class="reset-button text-center hidden">
            <button id="reset-button" class="btn btn-warning">Reset All Data</button>
        </div>

    <!-- Share Data Button -->
<div class="share-button text-center section">
    <button id="share-button" class="btn btn-info">Share My Map</button>
    <div id="share-link" class="hidden mt-3">
        <p>Your shareable link:</p>
        <input type="text" id="shareable-link" class="form-control" readonly>
        <button id="revoke-share-button" class="btn btn-warning mt-2">Revoke Sharing</button>
    </div>
</div>

       <!-- Map Section -->
<div id="map" class="section hidden"></div>

<!-- Chart Section -->
<div id="chart-wrapper" class="section">
    <div id="chart"></div>
</div>

<!-- Tables Section -->
<div id="tables" class="section">
    <h3 class="text-center">Visited States</h3>
    <div id="statesTable" class="table-responsive"></div>
    <h3 class="text-center">Visited Cities</h3>
    <div id="citiesTable" class="table-responsive"></div>
    <h3 class="text-center">Visited Countries</h3>
    <div id="countriesTable" class="table-responsive"></div>
    <h3 class="text-center">Visited ZIP Codes</h3>
    <div id="zipCodesTable" class="table-responsive"></div>
</div>

    <!-- Confirmation Modal -->
    <div id="confirmationModal" class="modal fade" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <form id="confirmation-form">
                    <div class="modal-header">
                        <h5 class="modal-title">Confirm Location Details</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <p>Please confirm or edit the location details:</p>
                        <!-- Dropdown for multiple location options -->
                        <div class="form-group hidden" id="location-options-group">
                            <label for="location-options">Select a Location:</label>
                            <select id="location-options" class="form-control"></select>
                        </div>
                        <div class="form-group">
                            <label for="confirm-city">City:</label>
                            <input type="text" id="confirm-city" class="form-control" required>
                        </div>
                        <div class="form-group" id="confirm-state-group">
                            <label for="confirm-state">State:</label>
                            <input type="text" id="confirm-state" class="form-control">
                        </div>
                        <div class="form-group">
                            <label for="confirm-zip">ZIP Code:</label>
                            <input type="text" id="confirm-zip" class="form-control">
                        </div>
                        <div class="form-group">
                            <label for="confirm-country">Country:</label>
                            <input type="text" id="confirm-country" class="form-control" readonly>
                        </div>
                        <!-- Hidden fields to store latitude and longitude -->
                        <input type="hidden" id="confirm-lat">
                        <input type="hidden" id="confirm-lon">
                    </div>
                    <div class="modal-footer">
                        <button type="submit" class="btn btn-success">Confirm</button>
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Firebase SDKs and Application Scripts -->
    <script type="module">
        // Import the necessary Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-analytics.js";
        import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.0.2/firebase-firestore.js";

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCtGCpWEF0H3eNJ7hasrgQIiVsIjhbQMN8",
            authDomain: "pinmap-31e5f.firebaseapp.com",
            projectId: "pinmap-31e5f",
            storageBucket: "pinmap-31e5f.firebasestorage.app",
            messagingSenderId: "816721437507",
            appId: "1:816721437507:web:90f786fb2b820d9247c5f6",
            measurementId: "G-DYJHWZY7V6"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const analytics = getAnalytics(app);
        const auth = getAuth(app);
        const db = getFirestore(app);

        console.log("Firebase initialized with config:", firebaseConfig);

        // DOM Elements
        const loginButton = document.getElementById('login-button');
        const logoutButton = document.getElementById('logout-button');
        const userInfo = document.getElementById('user-info');
        const userNameSpan = document.getElementById('user-name');
        const addLocationForm = document.getElementById('add-location-form');
        const locationForm = document.getElementById('location-form');
        const resetButton = document.getElementById('reset-button');
        const mapContainer = document.getElementById('map');
        const chartContainer = document.getElementById('chart');
        const tablesContainer = document.getElementById('tables');
        const confirmationModal = $('#confirmationModal');
        const confirmStateGroup = document.getElementById('confirm-state-group');

        // Application State
        let currentUser = null;
        let map = null;
        let heatmapLayer = null;
        let allData = [];
        let markers = [];
        let geonamesResultsGlobal = [];

        const markerMap = new Map();

        const geonamesUsername = "matthewjmiller07"; // Your GeoNames username

        // Initialize Leaflet Map
        function initializeMap() {
            console.log("Initializing map.");
            map = L.map('map').setView([20, 0], 2); // World view

            // Add OpenStreetMap tiles
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; OpenStreetMap contributors'
            }).addTo(map);

            // Initialize heatmap layer
            heatmapLayer = L.heatLayer([], { radius: 25 }).addTo(map);
            console.log("Map and heatmap layer initialized.");

            // Add click event to map for adding locations
            map.on('click', onMapClick);
            console.log("Map click event listener added.");
        }

        // Handle map click
        async function onMapClick(e) {
            const { lat, lng } = e.latlng;
            console.log(`Map clicked at Latitude: ${lat}, Longitude: ${lng}`);

            // Reverse geocode using GeoNames API
            try {
                const response = await fetch(`https://secure.geonames.org/findNearbyPlaceNameJSON?lat=${lat}&lng=${lng}&username=${geonamesUsername}`);
                const data = await response.json();
                console.log("GeoNames Reverse Geocoding data:", data);

                if (!data.geonames || data.geonames.length === 0) {
                    alert('Unable to retrieve location details. Please try again.');
                    return;
                }

                const geoData = data.geonames[0];
                let city = geoData.name || "";
                let state = geoData.adminName1 || "";
                let zip = geoData.postalcode || "";
                let country = geoData.countryName || "Unknown";

                console.log(`Reverse geocoded to City: ${city}, State: ${state}, ZIP: ${zip}, Country: ${country}`);

                // Always show confirmation modal to confirm or edit details
                showConfirmationModal(lat, lng, city, state, zip, country);
            } catch (error) {
                console.error("Error during reverse geocoding with GeoNames:", error);
                alert('Failed to retrieve location details. Please try again.');
            }
        }

        // Function to show confirmation modal
        function showConfirmationModal(lat, lon, city, state, zip, country, isMultipleOptions = false) {
    const locationOptionsGroup = document.getElementById('location-options-group');
    const locationOptionsSelect = document.getElementById('location-options');

    if (isMultipleOptions && geonamesResultsGlobal.length > 1) {
        // Multiple options, show dropdown
        // Clear any existing options
        locationOptionsSelect.innerHTML = '';

        geonamesResultsGlobal.forEach((geoData, index) => {
            const option = document.createElement('option');
            option.value = index;
            const optionText = `${geoData.name}, ${geoData.adminName1 || ''}, ${geoData.countryName}`;
            option.textContent = optionText;
            locationOptionsSelect.appendChild(option);
        });

        // Show the select element
        locationOptionsGroup.style.display = 'block';

        // Populate the modal fields with the first option
        const firstGeoData = geonamesResultsGlobal[0];
        populateModalFields(firstGeoData);

        // Remove previous event listener to prevent duplicates
        locationOptionsSelect.removeEventListener('change', locationOptionChangeHandler);

        // Add event listener to update modal fields when a different option is selected
        locationOptionsSelect.addEventListener('change', locationOptionChangeHandler);
    } else {
        // Single option, hide the select element
        locationOptionsGroup.style.display = 'none';

        // Populate modal fields
        document.getElementById('confirm-city').value = city;
        document.getElementById('confirm-state').value = state;
        document.getElementById('confirm-zip').value = zip;
        document.getElementById('confirm-country').value = country;
        document.getElementById('confirm-lat').value = lat;
        document.getElementById('confirm-lon').value = lon;

        // Show or hide the state field based on the availability of state data
        if (state) {
            confirmStateGroup.style.display = 'block';
            document.getElementById('confirm-state').required = true;
        } else {
            confirmStateGroup.style.display = 'none';
            document.getElementById('confirm-state').required = false;
        }
    }

    // Show the modal
    confirmationModal.modal('show');
}

// Define the event handler for location option change
function locationOptionChangeHandler() {
    const selectedIndex = document.getElementById('location-options').value;
    const selectedGeoData = geonamesResultsGlobal[selectedIndex];
    populateModalFields(selectedGeoData);
}

function populateModalFields(geoData) {
    const lat = parseFloat(geoData.lat);
    const lon = parseFloat(geoData.lng);
    const city = geoData.name || "Unknown City";
    const state = geoData.adminName1 || "";
    const zip = (geoData.postalCodes && geoData.postalCodes.length > 0) ? geoData.postalCodes[0].postalCode : "";
    const country = geoData.countryName || "Unknown Country";

    document.getElementById('confirm-city').value = city;
    document.getElementById('confirm-state').value = state;
    document.getElementById('confirm-zip').value = zip;
    document.getElementById('confirm-country').value = country;
    document.getElementById('confirm-lat').value = lat;
    document.getElementById('confirm-lon').value = lon;

    // Show or hide the state field based on the availability of state data
    if (state) {
        confirmStateGroup.style.display = 'block';
        document.getElementById('confirm-state').required = true;
    } else {
        confirmStateGroup.style.display = 'none';
        document.getElementById('confirm-state').required = false;
    }
}


        // Update UI Based on Authentication
        function updateUI(user) {
  if (user) {
    // User is signed in
    currentUser = user;
    loginButton.style.display = 'none';
    logoutButton.style.display = 'inline-block';
    userInfo.classList.remove('hidden');
    userNameSpan.textContent = user.displayName || user.email;

    // Show application sections
    addLocationForm.classList.remove('hidden');
    mapContainer.classList.remove('hidden');
    chartContainer.classList.remove('hidden');
    tablesContainer.classList.remove('hidden');
    resetButton.parentElement.classList.remove('hidden');
    shareButton.classList.remove('hidden');

    // Initialize map if not already initialized
    if (!map) {
      initializeMap();
    }

    // Load user data from Firestore
    const localData = localStorage.getItem('allData');
    if (localData) {
      const parsedLocalData = JSON.parse(localData);
      if (parsedLocalData.length > 0) {
        if (confirm('Merge local data with your account?')) {
          loadUserDataAndMerge(user.uid, parsedLocalData);
        } else {
          loadUserData(user.uid);
        }
        localStorage.removeItem('allData');
      } else {
        loadUserData(user.uid);
      }
    } else {
      loadUserData(user.uid);
    }
  } else {
    // User is signed out
    currentUser = null;
    loginButton.style.display = 'inline-block';
    logoutButton.style.display = 'none';
    userInfo.classList.add('hidden');

    // Show application sections for unauthenticated users
    addLocationForm.classList.remove('hidden');
    mapContainer.classList.remove('hidden');
    chartContainer.classList.remove('hidden');
    tablesContainer.classList.remove('hidden');
    resetButton.parentElement.classList.remove('hidden');
    shareButton.classList.add('hidden');

    // Initialize map if not already initialized
    if (!map) {
      initializeMap();
    }

    // Load data from localStorage
    loadLocalData();
  }
}

        // Authentication Event Listeners
        loginButton.addEventListener('click', () => {
            console.log("Login button clicked.");
            const provider = new GoogleAuthProvider();
            signInWithPopup(auth, provider)
                .then((result) => {
                    console.log('User signed in:', result.user);
                })
                .catch((error) => {
                    console.error('Error during sign-in:', error);
                    alert('Authentication failed. Please try again.');
                });
        });

        logoutButton.addEventListener('click', () => {
            console.log("Logout button clicked.");
            signOut(auth)
                .then(() => {
                    console.log('User signed out.');
                })
                .catch((error) => {
                    console.error('Error during sign-out:', error);
                    alert('Sign-out failed. Please try again.');
                });
        });

        // Listen to Authentication State Changes
        onAuthStateChanged(auth, (user) => {
  updateUI(user); // Update the UI based on auth state
});

        // Firestore References
        function getUserDocRef(uid) {
            return doc(db, 'users', uid);
        }

        // Load User Data from Firestore
        async function loadUserData() {
            if (!currentUser) return;

            const userDocRef = getUserDocRef(currentUser.uid);
            try {
                const docSnap = await getDoc(userDocRef);
                if (docSnap.exists()) {
                    allData = docSnap.data().allData || [];
                    console.log("User data loaded from Firestore:", allData);

                    // Clear existing markers
                    markers.forEach(marker => {
                        map.removeLayer(marker);
                    });
                    markers = [];

                    // Initialize Sets
                    const visitedStates = new Set();
                    const visitedCities = new Set();
                    const visitedCountries = new Set();
                    const visitedZipCodes = new Set();

                    allData.forEach(location => {
                        if (location.state && location.country.toLowerCase() === 'united states') {
        visitedStates.add(location.state);
    }
                        if (location.city) visitedCities.add(location.city);
                        if (location.country) visitedCountries.add(location.country);
                        if (location.zip) visitedZipCodes.add(location.zip);
                    });

                    console.log("Visited States:", visitedStates);
                    console.log("Visited Cities:", visitedCities);
                    console.log("Visited Countries:", visitedCountries);
                    console.log("Visited ZIP Codes:", visitedZipCodes);

                    // Add markers to the map
                    allData.forEach(location => {
                        const popupText = `${location.city}${(location.country.toLowerCase() === 'united states' && location.state) ? ', ' + location.state : ''}`;
                        const locationKey = `${location.lat},${location.lon}_${location.city.toLowerCase()}_${location.state.toLowerCase()}`;
                        const popupContent = `
                            <strong>${popupText}</strong><br>
                            Visits: ${location.visitCount}<br>
                            <button class="btn btn-xs btn-danger" onclick="deleteLocation('${locationKey}')">Delete</button>
                        `;
                        const marker = L.marker([location.lat, location.lon]).addTo(map)
                            .bindPopup(popupContent);
                        markers.push(marker);
                        markerMap.set(locationKey, marker);
                        console.log("Marker added to map:", popupText);
                    });

                    // Update visualizations
                    updateChart(visitedCountries, visitedStates, visitedCities, visitedZipCodes);
                    updateStatesTable(visitedStates);
                    updateCitiesTable(visitedCities);
                    updateCountriesTable(visitedCountries);
                    updateZipCodesTable(visitedZipCodes);

                    // Initialize heatmap with loaded data
                    updateHeatmap();
                } else {
                    console.log("No data found for this user. Initializing empty data structures.");
                    allData = [];
                    saveData();
                }
            } catch (error) {
                console.error('Error fetching user data:', error);
                alert('Failed to load your data. Please try again.');
            }
        }

        // Save User Data to Firestore
        async function saveData() {
            if (!currentUser) return;

            const userDocRef = getUserDocRef(currentUser.uid);
            try {
                await setDoc(userDocRef, { allData }, { merge: true });
                console.log('User data saved successfully.');
            } catch (error) {
                console.error('Error saving user data:', error);
                alert('Failed to save your data. Please try again.');
            }
        }

        // Handle Add Location Form Submission
        // Modify the location form submission handler
        locationForm.addEventListener('submit', async (e) => {
    e.preventDefault();

    const city = document.getElementById('city').value.trim();
    const state = document.getElementById('state').value.trim();
    const zip = document.getElementById('zip').value.trim();

    // Allow adding with just city or just state
    if (!city && !state) {
        alert('Please enter at least a city or a state.');
        return;
    }

    // Perform initial geocoding request based on user input
    try {
        let query = '';
        if (city && state) {
            query = `name_equals=${encodeURIComponent(city)}&adminName1=${encodeURIComponent(state)}`;
        } else if (city) {
            query = `name_equals=${encodeURIComponent(city)}`;
        } else if (state) {
            query = `adminName1=${encodeURIComponent(state)}`;
        }

        const response = await fetch(`https://secure.geonames.org/searchJSON?${query}&maxRows=20&username=${geonamesUsername}`);
        const data = await response.json();
        console.log("GeoNames Initial Geocoding data:", data);

        if (data.totalResultsCount === 0 || data.geonames.length === 0) {
            alert('Location not found. Please try a different city or state.');
            return;
        }

        const geonamesResults = data.geonames;

        if (geonamesResults.length === 1) {
            const geoData = geonamesResults[0];
            const lat = parseFloat(geoData.lat);
            const lon = parseFloat(geoData.lng);
            const standardizedCity = geoData.name || city || "Unknown City";
            const standardizedState = geoData.adminName1 || state || "";
            const standardizedZip = (geoData.postalCodes && geoData.postalCodes.length > 0) ? geoData.postalCodes[0].postalCode : zip || "";
            const country = geoData.countryName || "Unknown Country";

            console.log(`Initial Geocoding Result: City: ${standardizedCity}, State: ${standardizedState}, ZIP: ${standardizedZip}, Country: ${country}, Coordinates: (${lat}, ${lon})`);

            // Always show confirmation modal to confirm or edit details
            showConfirmationModal(lat, lon, standardizedCity, standardizedState, standardizedZip, country);
        } else {
            // Multiple results, show options
            geonamesResultsGlobal = geonamesResults; // Store globally for access in event handlers
            showConfirmationModal(null, null, null, null, null, null, true);
        }
    } catch (error) {
        console.error('Error fetching coordinates from GeoNames:', error);
        alert('Failed to fetch location coordinates. Please try again.');
    }
});

        // Add Location Function
        function addLocation(lat, lon, city, state, zip, country) {
    console.log(`Adding location: ${city}, ${state}, ${zip}, ${country} at (${lat}, ${lon})`);

    // Standardize country names to prevent duplicates
    country = standardizeCountryName(country);

    // Create a unique key for the location
    const locationKey = `${lat},${lon}_${city.toLowerCase()}_${state.toLowerCase()}`;

    // Check if the location already exists
    const existingLocation = allData.find(loc => 
        loc.lat === lat && 
        loc.lon === lon && 
        loc.city.toLowerCase() === city.toLowerCase() && 
        loc.state.toLowerCase() === state.toLowerCase()
    );
    let newLocation = null;

    if (existingLocation) {
        existingLocation.visitCount += 1;
        console.log("Existing location found. Incrementing visit count.");

        // Update the corresponding marker's popup
        const marker = markerMap.get(locationKey);
        if (marker) {
            const updatedPopupContent = `
                <strong>${existingLocation.city}</strong>${(existingLocation.state) ? ', ' + existingLocation.state : ''}<br>
                Visits: ${existingLocation.visitCount}<br>
                <button class="btn btn-xs btn-danger" onclick="deleteLocation('${locationKey}')">Delete</button>
            `;
            marker.setPopupContent(updatedPopupContent);
            console.log(`Marker popup updated for ${existingLocation.city}`);
        } else {
            console.warn(`Marker not found for existing location: ${existingLocation.city}`);
        }
    } else {
        newLocation = {
            lat,
            lon,
            city,
            state: state || '', // Only record state if available
            zip,
            country,
            visitCount: 1,
            livedIn: false
        };
        allData.push(newLocation);
        console.log("New location added.");

        // Add a new marker for the new location
        const popupText = `${city}${(state) ? ', ' + state : ''}${(country) ? ', ' + country : ''}`;
        addMarker(lat, lon, popupText, newLocation);
    }

    // Save updated data to Firestore
    saveData();

    // Recreate Sets
    const visitedStates = new Set();
    const visitedCities = new Set();
    const visitedCountries = new Set();
    const visitedZipCodes = new Set();

    allData.forEach(location => {
        if (location.state && location.country.toLowerCase() === 'united states') {
        visitedStates.add(location.state);
    }
        if (location.city) visitedCities.add(location.city);
        if (location.country) visitedCountries.add(location.country);
        if (location.zip) visitedZipCodes.add(location.zip);
    });

    // Update visualizations
    updateChart(visitedCountries, visitedStates, visitedCities, visitedZipCodes);
    updateStatesTable(visitedStates);
    updateCitiesTable(visitedCities);
    updateCountriesTable(visitedCountries);
    updateZipCodesTable(visitedZipCodes);

    // Update heatmap data
    updateHeatmap();
}


        // Handle Confirmation Modal Submission
        document.getElementById('confirmation-form').addEventListener('submit', async function(event) {
    event.preventDefault();
    const confirmedCity = document.getElementById('confirm-city').value.trim();
    const confirmedState = document.getElementById('confirm-state').value.trim();
    const confirmedZip = document.getElementById('confirm-zip').value.trim();
    const confirmedCountry = document.getElementById('confirm-country').value.trim();
    const lat = parseFloat(document.getElementById('confirm-lat').value);
    const lon = parseFloat(document.getElementById('confirm-lon').value);

    if (!confirmedCity) {
        alert('City is required.');
        return;
    }

    // If the state field is visible and required, ensure state is provided
    if (confirmStateGroup.style.display !== 'none' && !confirmedState) {
        alert('State is required for this location.');
        return;
    }

    // Hide the modal
    confirmationModal.modal('hide');

    // Add the location
    addLocation(lat, lon, confirmedCity, confirmedState, confirmedZip, confirmedCountry);
});

        // Make deleteLocation accessible globally
        window.deleteLocation = deleteLocation;

        // Function to standardize country names
        function standardizeCountryName(country) {
    const countryMap = {
        'usa': 'United States',
        'us': 'United States',
        'u.s.a.': 'United States',
        'u.s.': 'United States',
        'uk': 'United Kingdom',
        'gb': 'United Kingdom',
        'great britain': 'United Kingdom',
        // Add more mappings as needed
    };

    const lowerCountry = country.toLowerCase();
    return countryMap[lowerCountry] || country;
}

        // Add Marker to Map
        function addMarker(lat, lon, popupText, location) {
    if (!map || !heatmapLayer) return;

    // Create a unique key for the location
    const locationKey = `${lat},${lon}_${location.city.toLowerCase()}_${location.state.toLowerCase()}`;

    // Define the popup content with a Delete button
    const popupContent = `
        <strong>${popupText}</strong><br>
        Visits: ${location.visitCount}<br>
        Lived In: ${location.livedIn ? 'Yes' : 'No'}<br>
        <button class="btn btn-xs btn-danger" onclick="deleteLocation('${locationKey}')">Delete</button>
    `;

    const marker = L.marker([lat, lon]).addTo(map)
        .bindPopup(popupContent);
    markers.push(marker);
    console.log("Marker added to map:", popupText);

    // Store the marker in the markerMap
    markerMap.set(locationKey, marker);

    // Store the location data with the marker
    marker.locationData = location;
}

function refreshMarkers() {
    markers.forEach(marker => {
        if (marker.locationData) {
            const loc = marker.locationData;
            const popupText = `${loc.city}${(loc.state) ? ', ' + loc.state : ''}${(loc.country) ? ', ' + loc.country : ''}`;
            const popupContent = `
                <strong>${popupText}</strong><br>
                Visits: ${loc.visitCount}<br>
                Lived In: ${loc.livedIn ? 'Yes' : 'No'}<br>
                <button class="btn btn-xs btn-danger" onclick="deleteLocation('${loc.lat},${loc.lon}_${loc.city.toLowerCase()}_${loc.state.toLowerCase()}')">Delete</button>
            `;
            marker.setPopupContent(popupContent);
        } else {
            console.warn("Marker's locationData is undefined. Skipping this marker.");
        }
    });
}
function refreshVisualizations() {
    // Update markers
    refreshMarkers();

    // Other updates...
    // Rebuild the sets
    const visitedStates = new Set();
    const visitedCities = new Set();
    const visitedCountries = new Set();
    const visitedZipCodes = new Set();

    allData.forEach(location => {
        if (location.state && location.country.toLowerCase() === 'united states') {
            visitedStates.add(location.state);
        }
        if (location.city) visitedCities.add(location.city);
        if (location.country) visitedCountries.add(location.country);
        if (location.zip) visitedZipCodes.add(location.zip);
    });

    // Update visualizations
    updateChart(visitedCountries, visitedStates, visitedCities, visitedZipCodes);
    updateStatesTable(visitedStates);
    updateCitiesTable(visitedCities);
    updateCountriesTable(visitedCountries);
    updateZipCodesTable(visitedZipCodes);

    // Update heatmap data
    updateHeatmap();
}

        // Delete Location Function
        async function deleteLocation(locationKey) {
    console.log(`Deleting location with key: ${locationKey}`);

    // Confirm deletion
    if (!confirm("Are you sure you want to delete this location?")) {
        return;
    }

    // Retrieve the marker from the markerMap
    const marker = markerMap.get(locationKey);
    if (marker) {
        // Remove marker from the map
        map.removeLayer(marker);
        markerMap.delete(locationKey);
        console.log("Marker removed from map.");
    } else {
        console.warn("Marker not found for the given location key.");
    }

    // Parse the locationKey to extract lat, lon, city, and state
    const [latLon, city, state] = locationKey.split('_');
    const [lat, lon] = latLon.split(',').map(coord => parseFloat(coord));

    // Find the location in allData
    const locationIndex = allData.findIndex(loc => 
        loc.lat === lat && 
        loc.lon === lon && 
        loc.city.toLowerCase() === city.toLowerCase() && 
        loc.state.toLowerCase() === state.toLowerCase()
    );

    if (locationIndex !== -1) {
        // Remove the location from allData
        allData.splice(locationIndex, 1);
        console.log("Location removed from allData.");
    } else {
        console.warn("Location not found in allData.");
    }

    // Save the updated data to Firestore
    await saveData();

    // Recreate Sets for Visualization
    const visitedStates = new Set();
    const visitedCities = new Set();
    const visitedCountries = new Set();
    const visitedZipCodes = new Set();

    allData.forEach(location => {
        if (location.state && location.country.toLowerCase() === 'united states') {
            visitedStates.add(location.state);
        }
        if (location.city) visitedCities.add(location.city);
        if (location.country) visitedCountries.add(location.country);
        if (location.zip) visitedZipCodes.add(location.zip);
    });

    // Refresh Markers
    refreshMarkers();

    // Update UI Visualizations
    updateChart(visitedCountries, visitedStates, visitedCities, visitedZipCodes);
    updateStatesTable(visitedStates);
    updateCountriesTable(visitedCountries);
    updateZipCodesTable(visitedZipCodes);

    // Update heatmap data
    updateHeatmap();
    updateCitiesTable(visitedCities);


    alert("Location deleted successfully.");
}

        // Update Heatmap
        function updateHeatmap() {
    if (!heatmapLayer) return;

    const heatData = allData.map(location => [location.lat, location.lon, location.visitCount]);
    heatmapLayer.setLatLngs(heatData);
    console.log("Heatmap updated:", heatData.length, "points.");
}

        // Update Chart using D3.js
        function updateChart(visitedCountries, visitedStates, visitedCities, visitedZipCodes) {
    console.log('Updating chart.');

    // Clear previous chart
    d3.select('#chart').html('');
    console.log('Cleared existing chart content.');

    // Data for the chart
    const data = [
        { label: 'Countries', value: visitedCountries.size },
        { label: 'States', value: visitedStates.size },
        { label: 'Cities', value: visitedCities.size },
        { label: 'ZIP Codes', value: visitedZipCodes.size }
    ];

    console.log('Chart Data:', data);

    // Check if there is any data to render
    if (data.every(d => d.value === 0)) {
        console.warn('No data available to render the chart.');
        d3.select('#chart').append('p')
            .text('No data to display')
            .attr('style', 'text-align: center; color: gray; font-size: 16px; margin-top: 20px;');
        return;
    }

    // Dynamically calculate width based on the container
    const containerWidth = document.getElementById('chart').offsetWidth;
    const width = containerWidth; // Full width of the container
    console.log('Container width:', containerWidth);

    // Adjust height dynamically for mobile
    const isMobile = window.innerWidth <= 576; // Mobile screen width
    const height = isMobile ? 350 : 500; // Set height based on device type
    console.log('Chart height:', height);

    const margin = { top: 60, right: 40, bottom: 60, left: 80 };
    console.log('Margins:', margin);

    const svg = d3.select('#chart')
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .attr('viewBox', `0 0 ${width} ${height}`)
        .attr('preserveAspectRatio', 'xMidYMid meet');
    console.log('SVG element created.');

    const x = d3.scaleBand()
        .domain(data.map(d => d.label))
        .range([margin.left, width - margin.right])
        .padding(0.2);
    console.log('X scale domain:', data.map(d => d.label));
    console.log('X scale range:', [margin.left, width - margin.right]);

    const y = d3.scaleLinear()
        .domain([0, d3.max(data, d => d.value) + 2])
        .nice()
        .range([height - margin.bottom, margin.top]);
    console.log('Y scale domain:', [0, d3.max(data, d => d.value) + 2]);
    console.log('Y scale range:', [height - margin.bottom, margin.top]);

    // Render X-axis
    svg.append('g')
        .attr('transform', `translate(0, ${height - margin.bottom})`)
        .call(d3.axisBottom(x).tickSizeOuter(0))
        .selectAll('text')
        .style('font-size', isMobile ? '12px' : '14px')
        .style('text-anchor', 'middle');
    console.log('X-axis rendered.');

    // Render Y-axis
    svg.append('g')
        .attr('transform', `translate(${margin.left}, 0)`)
        .call(d3.axisLeft(y).ticks(null, 's'))
        .selectAll('text')
        .style('font-size', isMobile ? '12px' : '14px');
    console.log('Y-axis rendered.');

    // Add tooltip
    const tooltip = d3.select('body')
        .append('div')
        .attr('id', 'chart-tooltip')
        .style('position', 'absolute')
        .style('background-color', 'rgba(0, 0, 0, 0.75)')
        .style('color', '#fff')
        .style('padding', '8px')
        .style('border-radius', '5px')
        .style('opacity', 0)
        .style('pointer-events', 'none')
        .style('font-size', isMobile ? '12px' : '14px');
    console.log('Tooltip added.');

    // Create bars with hover functionality
    const bars = svg.append('g')
        .selectAll('rect')
        .data(data)
        .join('rect')
        .attr('x', d => x(d.label))
        .attr('y', d => y(d.value))
        .attr('height', d => y(0) - y(d.value))
        .attr('width', x.bandwidth())
        .attr('fill', '#1f77b4')
        .attr('opacity', 0.8)
        .on('mouseover', (event, d) => {
            console.log('Mouseover on bar:', d);
            tooltip.style('opacity', 1)
                .html(`<strong>${d.label}</strong>: ${d.value}`)
                .style('left', `${event.pageX + 10}px`)
                .style('top', `${event.pageY - 28}px`);
        })
        .on('mousemove', (event) => {
            tooltip.style('left', `${event.pageX + 10}px`)
                .style('top', `${event.pageY - 28}px`);
        })
        .on('mouseout', () => {
            tooltip.style('opacity', 0);
        });
    console.log('Bars created:', bars.size());

    // Add chart title
    svg.append('text')
        .attr('x', width / 2)
        .attr('y', margin.top / 2)
        .attr('text-anchor', 'middle')
        .attr('font-size', isMobile ? '18px' : '24px') // Adjust font size for mobile
        .attr('font-weight', 'bold')
        .text('Places Visited');
    console.log('Chart title added.');
}

        // Update States Table
        function updateStatesTable(visitedStates) {
    console.log("Updating States Table.");

    // Clear previous table
    d3.select('#statesTable').html('');

    // Convert visitedStates to an array of unique states with visit counts
    const data = Array.from(visitedStates).map(stateName => {
        // Find all locations that match the state and are in the US
        const locations = allData.filter(d => 
            d.state.toLowerCase() === stateName.toLowerCase() && 
            d.country.toLowerCase() === 'united states'
        );
        // Calculate total visit count for the state
        const totalVisits = locations.reduce((sum, loc) => sum + loc.visitCount, 0);
        return {
            state: stateName,
            visitCount: totalVisits
        };
    });

    // Remove any states with zero visits (in case any slipped through)
    const filteredData = data.filter(d => d.visitCount > 0);

    // Sort data alphabetically by state name
    filteredData.sort((a, b) => a.state.localeCompare(b.state));

    console.log('States Data:', filteredData);

    // Create the table element
    const table = d3.select('#statesTable').append('table').attr('class', 'table table-striped table-bordered');
    const thead = table.append('thead');
    const tbody = table.append('tbody');
    const tfoot = table.append('tfoot');

    // Define table headers
    const headers = ['State', 'Visit Count'];

    // Append headers to the thead
    thead.append('tr')
        .selectAll('th')
        .data(headers)
        .enter()
        .append('th')
        .text(d => d)
        .style('cursor', 'pointer');

    // Append rows to the tbody
    const rows = tbody.selectAll('tr')
        .data(filteredData)
        .enter()
        .append('tr');

    // Append cells to each row
    rows.selectAll('td')
        .data(d => [d.state, d.visitCount])
        .enter()
        .append('td')
        .text(d => d);

    // Calculate Running Total as the number of unique states
    const runningTotal = filteredData.length;
    console.log('Running Total (States):', runningTotal);

    // Append a footer row with the running total
    tfoot.append('tr')
        .selectAll('td')
        .data(['Total', runningTotal])
        .enter()
        .append('td')
        .attr('colspan', '2') // Span across two columns
        .attr('style', 'font-weight: bold; text-align: right; background-color: #f2f2f2;')
        .text(d => d);
}

        // Update Cities Table
        function updateCitiesTable(visitedCities) {
    console.log("Updating Cities Table.");

    // Clear previous table
    d3.select('#citiesTable').html('');

    // Convert visitedCities to an array of unique cities with visit counts
    const data = Array.from(visitedCities).map(cityName => {
        // Find all locations that match the city
        const locations = allData.filter(d => d.city.toLowerCase() === cityName.toLowerCase());
        // Calculate total visit count for the city
        const totalVisits = locations.reduce((sum, loc) => sum + loc.visitCount, 0);
        // Check if any of the locations are marked as lived in
        const livedIn = locations.some(loc => loc.livedIn);
        return {
            city: cityName,
            state: Array.from(new Set(locations.map(loc => loc.state))).join(', '),
            livedIn: livedIn,
            visitCount: totalVisits
        };
    });

    // Sort data alphabetically by city name
    data.sort((a, b) => a.city.localeCompare(b.city));

    console.log('Cities Data:', data);

    // Create the table element
    const table = d3.select('#citiesTable').append('table').attr('class', 'table table-striped table-bordered');
    const thead = table.append('thead');
    const tbody = table.append('tbody');
    const tfoot = table.append('tfoot');

    // Define table headers
    const headers = ['City', 'State', 'Lived In', 'Visit Count', 'Actions'];

    // Append headers to the thead
    thead.append('tr')
        .selectAll('th')
        .data(headers)
        .enter()
        .append('th')
        .text(d => d);

    // Append rows to the tbody
    const rows = tbody.selectAll('tr')
        .data(data)
        .enter()
        .append('tr');

    // Append cells to each row
    rows.each(function(d) {
        const row = d3.select(this);
        row.append('td').text(d.city);
        row.append('td').text(d.state);

        // Editable 'Lived In' checkbox
        row.append('td')
            .append('input')
            .attr('type', 'checkbox')
            .property('checked', d.livedIn)
            .on('change', function(event) {
                const isChecked = this.checked;
                updateLivedInStatusForCity(d.city, isChecked);
            });

        // Editable visit count cell
        row.append('td')
            .append('input')
            .attr('type', 'number')
            .attr('min', 1)
            .attr('value', d.visitCount)
            .attr('style', 'width: 80px;')
            .on('change', function(event) {
                const newVisitCount = parseInt(this.value);
                if (newVisitCount > 0) {
                    updateVisitCountForCity(d.city, newVisitCount);
                } else {
                    alert('Visit count must be at least 1.');
                    this.value = d.visitCount;
                }
            });

        // Actions cell with Delete button
        row.append('td')
            .append('button')
            .attr('class', 'btn btn-xs btn-danger')
            .text('Delete')
            .on('click', function() {
                if (confirm(`Are you sure you want to delete all entries for city: ${d.city}?`)) {
                    deleteCity(d.city);
                }
            });
    });

    // Calculate Running Total as the number of unique cities
    const runningTotal = data.length;
    console.log('Running Total (Cities):', runningTotal);

    // Append a footer row with the running total
    tfoot.append('tr')
        .append('td')
        .attr('colspan', headers.length)
        .attr('style', 'font-weight: bold; text-align: right;')
        .text(`Total Cities: ${runningTotal}`);
}

function updateLivedInStatusForCity(cityName, livedInStatus) {
    // Find all locations matching the city
    const locations = allData.filter(loc => loc.city.toLowerCase() === cityName.toLowerCase());

    if (locations.length > 0) {
        // Update the 'livedIn' status for each location
        locations.forEach(loc => {
            loc.livedIn = livedInStatus;
        });

        // Save updated data to Firestore
        saveData();

        // Refresh visualizations if necessary
        refreshVisualizations();
    }
}

function updateVisitCountForCity(cityName, newVisitCount) {
    // Find all locations matching the city
    const locations = allData.filter(loc => loc.city.toLowerCase() === cityName.toLowerCase());

    // Calculate the current total visits for the city
    const currentTotalVisits = locations.reduce((sum, loc) => sum + loc.visitCount, 0);

    // Calculate the difference in visit counts
    const visitDifference = newVisitCount - currentTotalVisits;

    if (visitDifference !== 0) {
        // Update each location's visit count proportionally
        locations.forEach(loc => {
            const locProportion = loc.visitCount / currentTotalVisits;
            loc.visitCount += Math.round(visitDifference * locProportion);

            // Ensure visit count is at least 1
            if (loc.visitCount < 1) {
                loc.visitCount = 1;
            }
        });

        // Save updated data to Firestore
        saveData();

        // Refresh visualizations
        refreshVisualizations();
    }
}

function deleteCity(cityName) {
    console.log(`Deleting city: ${cityName}`);

    // Remove locations matching the city from allData
    allData = allData.filter(loc => loc.city.toLowerCase() !== cityName.toLowerCase());

    // Remove corresponding markers from the map
    markers.forEach(marker => {
        if (marker.locationData && marker.locationData.city.toLowerCase() === cityName.toLowerCase()) {
            map.removeLayer(marker); // Remove marker from the map
        }
    });

    // Remove markers from the markers array
    markers = markers.filter(marker => !(marker.locationData && marker.locationData.city.toLowerCase() === cityName.toLowerCase()));

    console.log("Updated allData after city deletion:", allData);

    // Save updated data to Firestore
    saveData().then(() => {
        console.log("Data saved after city deletion.");
        
        // Refresh visualizations to reflect updated data
        refreshVisualizations();

        alert(`City "${cityName}" has been deleted.`);
    }).catch(error => {
        console.error("Error saving data after city deletion:", error);
        alert("An error occurred while saving the updated data.");
    });
}

        // Update Countries Table
        function updateCountriesTable(visitedCountries) {
            console.log("Updating Countries Table.");

            // Clear previous table
            d3.select('#countriesTable').html('');

            // Convert visitedCountries to an array of unique countries with visit counts
            const data = Array.from(visitedCountries).map(countryName => {
                // Find all locations that match the country
                const locations = allData.filter(d => d.country.toLowerCase() === countryName.toLowerCase());
                // Calculate total visit count for the country
                const totalVisits = locations.reduce((sum, loc) => sum + loc.visitCount, 0);
                return {
                    country: countryName,
                    visitCount: totalVisits
                };
            });

            // Sort data alphabetically by country name
            data.sort((a, b) => a.country.localeCompare(b.country));

            console.log('Countries Data:', data);

            // Create the table element
            const table = d3.select('#countriesTable').append('table').attr('class', 'table table-striped table-bordered');
            const thead = table.append('thead');
            const tbody = table.append('tbody');
            const tfoot = table.append('tfoot');

            // Define table headers
            const headers = ['Country', 'Visit Count'];

            // Append headers to the thead
            thead.append('tr')
                .selectAll('th')
                .data(headers)
                .enter()
                .append('th')
                .text(d => d)
                .style('cursor', 'pointer') // Optional
                .on('click', function(event, d) {
                    // Optional: Implement sorting functionality
                });

            // Append rows to the tbody
            const rows = tbody.selectAll('tr')
                .data(data)
                .enter()
                .append('tr');

            // Append cells to each row
            rows.selectAll('td')
                .data(d => [d.country, d.visitCount])
                .enter()
                .append('td')
                .text(d => d);

            // Calculate Running Total as the number of unique countries
            const runningTotal = data.length;
            console.log('Running Total (Countries):', runningTotal);

            // Append a footer row with the running total
            tfoot.append('tr')
                .selectAll('td')
                .data(['Total', runningTotal])
                .enter()
                .append('td')
                .attr('colspan', '2') // Span across two columns for proper alignment
                .attr('style', 'font-weight: bold; text-align: right; background-color: #f2f2f2;')
                .text(d => d);
        }

        // Update ZIP Codes Table
        function updateZipCodesTable(visitedZipCodes) {
            console.log("Updating ZIP Codes Table.");

            // Clear previous table
            d3.select('#zipCodesTable').html('');

            // Convert visitedZipCodes to an array of unique ZIP codes with visit counts
            const data = Array.from(visitedZipCodes).map(zipCode => {
                // Find all locations that match the ZIP code
                const locations = allData.filter(d => d.zip === zipCode);
                // Calculate total visit count for the ZIP code
                const totalVisits = locations.reduce((sum, loc) => sum + loc.visitCount, 0);
                return {
                    zipCode: zipCode,
                    visitCount: totalVisits
                };
            });

            // Sort data numerically by ZIP code
            data.sort((a, b) => a.zipCode.localeCompare(b.zipCode));
            // Alternatively, for numerical sorting:
            // data.sort((a, b) => parseInt(a.zipCode) - parseInt(b.zipCode));

            console.log('ZIP Codes Data:', data);

            // Create the table element
            const table = d3.select('#zipCodesTable').append('table').attr('class', 'table table-striped table-bordered');
            const thead = table.append('thead');
            const tbody = table.append('tbody');
            const tfoot = table.append('tfoot');

            // Define table headers
            const headers = ['ZIP Code', 'Visit Count'];

            // Append headers to the thead
            thead.append('tr')
                .selectAll('th')
                .data(headers)
                .enter()
                .append('th')
                .text(d => d)
                .style('cursor', 'pointer') // Optional
                .on('click', function(event, d) {
                    // Optional: Implement sorting functionality
                });

            // Append rows to the tbody
            const rows = tbody.selectAll('tr')
                .data(data)
                .enter()
                .append('tr');

            // Append cells to each row
            rows.selectAll('td')
                .data(d => [d.zipCode, d.visitCount])
                .enter()
                .append('td')
                .text(d => d);

            // Calculate Running Total as the number of unique ZIP codes
            const runningTotal = data.length;
            console.log('Running Total (ZIP Codes):', runningTotal);

            // Append a footer row with the running total
            tfoot.append('tr')
                .selectAll('td')
                .data(['Total', runningTotal])
                .enter()
                .append('td')
                .attr('colspan', '2') // Span across two columns for proper alignment
                .attr('style', 'font-weight: bold; text-align: right; background-color: #f2f2f2;')
                .text(d => d);
        }

        // Clear All Data from UI (when user logs out)
        function clearAllData() {
            console.log("Clearing all data from UI.");
            allData = [];

            // Clear heatmap data
            if (heatmapLayer) {
                heatmapLayer.setLatLngs([]);
                console.log("Heatmap data cleared.");
            }

            // Clear markers
            markers.forEach(marker => {
                map.removeLayer(marker);
            });
            markers = [];
            markerMap.clear();
            console.log("All map markers removed.");

            // Clear tables and chart
            d3.select('#statesTable').html('');
            d3.select('#citiesTable').html('');
            d3.select('#countriesTable').html('');
            d3.select('#zipCodesTable').html('');
            d3.select('#chart').html('');
            console.log("Tables and chart cleared.");
        }

        // Reset All Data Function
        resetButton.addEventListener('click', () => {
            console.log("Reset button clicked.");
            if (confirm("Are you sure you want to reset all your data? This action cannot be undone.")) {
                allData = [];
                saveData(); // Save the cleared data to Firestore
                clearAllData();
                alert("All data has been reset.");
                console.log("All data reset.");
            }
        });

        // DOM Elements
const shareButton = document.getElementById('share-button');
const shareLinkDiv = document.getElementById('share-link');
const shareableLinkInput = document.getElementById('shareable-link');
const revokeShareButton = document.getElementById('revoke-share-button');

// Application State
let shareToken = null;

// Event Listener for Share Button
// Event Listener for Share Button
shareButton.addEventListener('click', async () => {
  if (!currentUser) {
    alert("You must be signed in to share your map.");
    return;
  }

  // Generate a unique share token if it doesn't exist
  if (!shareToken) {
    shareToken = generateShareToken();
    await saveSharedData(shareToken);
  }

  // Get the base path up to the current directory
  const basePath = window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/'));

  // Construct the correct shareable link
  const link = `${window.location.origin}${basePath}/shared.html?token=${shareToken}`;
  shareableLinkInput.value = link;
  shareLinkDiv.style.display = 'block';
  alert(`Shareable link created: ${link}`);
});

revokeShareButton.addEventListener('click', async () => {
  if (!currentUser || !shareToken) return;

  try {
    // Delete shared data from Firestore
    await deleteSharedData(shareToken);

    // Reset shareToken and update UI
    shareToken = null;
    shareLinkDiv.style.display = 'none';
    alert("Sharing has been revoked.");
  } catch (error) {
    console.error('Error revoking shared data:', error);
    alert('Failed to revoke sharing. Please try again.');
  }
});

function generateShareToken() {
  // Use a combination of user ID and a timestamp
  return `${currentUser.uid}_${Date.now()}`;
}

async function saveSharedData(token) {
  if (!currentUser) return;

  try {
    await setDoc(doc(db, 'sharedData', token), { 
      allData, 
      ownerUid: currentUser.uid, 
      ownerName: currentUser.displayName || currentUser.email 
    }, { merge: true });
    console.log('Shared data saved successfully.');
  } catch (error) {
    console.error('Error saving shared data:', error);
    alert('Failed to share your data. Please try again.');
  }
}

async function deleteSharedData(token) {
  try {
    await deleteDoc(doc(db, 'sharedData', token));
    console.log('Shared data deleted successfully.');
  } catch (error) {
    console.error('Error deleting shared data:', error);
    alert('Failed to revoke sharing. Please try again.');
  }
}

        // Handle Confirmation Modal Submission
        // (Already handled above; this redundant block has been removed)

        // Make deleteLocation accessible globally
        window.deleteLocation = deleteLocation;
    </script>
    <!-- jQuery (required for Bootstrap 3) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <!-- Bootstrap JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
    <!-- D3.js -->
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Leaflet.heat Plugin -->
    <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>
</body>
</html>